# 1 use strict
在JavaScript中，"use strict"是一种严格模式的声明。
通过在脚本或函数的顶部添加"use strict"，可以启用严格模式，从而改变JavaScript的默认行为。 

严格模式有以下几个作用： 
1. 变量必须声明：在严格模式下，变量必须通过var、let或const关键字进行声明，否则会抛出错误。 
2. 禁止意外创建全局变量：在严格模式下，不使用var、let或const关键字声明的变量将不会自动成为全局变量，而是会引发错误。 
3. 禁止删除变量、函数和函数参数：在严格模式下，无法使用delete操作符删除变量、函数或函数参数。 
4. 禁止重复的参数名：在严格模式下，函数的参数名不能重复。 
5. 禁止使用八进制字面量：在严格模式下，不允许使用八进制字面量（例如使用前导零的数字）。 
6. 禁止使用保留字作为变量名：在严格模式下，保留字（例如implements、interface、let、package等）不能用作变量名。 
7. this的值为undefined：在严格模式下，全局作用域中的this的值是undefined，而不是指向全局对象。 使用严格模式可以帮助开发者避免一些常见的错误，并使JavaScript更加严格和可靠。

要在整个脚本中启用严格模式，可以在<font color='red'>脚本的顶部</font>添加"use strict"。要在函数中启用严格模式，可以在函数体的顶部添加"use strict"。

# 2 变量

```js
let msg = "yes";  // 基本变量的定义    也可以使用var来定义变量，最新的一般使用let来定义
const constantValue = 1000;  // 常量的定义
```

## 2.1 数据类型

7种原始类型和1种引用类型

```javascript
// Number类型
let a = 123;
let b = 3.14;
let c = Infinity; // -Infinity 负无穷  NaN 不是数字，任何对NaN的计算都会返回NaN

// BigInt 类型：  大于 2^53 - 1   或者 小于 -(2^53 - 1)的整数无法通过Number类型来表示  
let d = 1234567890123456789012345678901234567890n; // 后面的n表示这是一个BigInt类型

// String 类型
let str = "hello";
let str2 = `can embed another ${str}`;  // 可以通过反引号`来允许我们将变量和表达式包装在${...}中，来将它们嵌入到字符串中

// Boolean类型
let yes = true;
let no = false;
let big = 5 > 4;

// null 值
let age = null; // null不是一个“对不存在的对象的引用”或“null指针”。javascript中的null表示的是“无”，“空”或“值未知”的特殊值

// undefined 值：其含义是未被赋值
let name;
alert(name) // 变量已经声明，但是没有被赋值，那它的值就是undefined 
let name1 = "maple";
name1 = undefined; //可以通过赋值的方法将undefined赋值给变量

// 此外还包括 Object类型和Symbol类型

// 可以通过typeof运算符来获取变量的类型
typeof(yes) //boolean 
```

## 2.2 数据类型转换

boolean、string 和number类型的互相转换

```javascript
// 字符串转换
let a = 1;
a = string(a);
typeof(a); // string
let n = 1;
a + n; // string + number  ->  string


// number类型的转换
// undefined -> NaN    null -> 0   true, false -> 1, 0
let b = "6" / "2"; 
typeof(b); // number
let age = Number("age"); // NaN
let age = Number("15"); // number

Boolean(1); // true
Boolean(0); // false
Boolean("hello"); // true
Boolean(""); // false
```

<font color='red'>这里有一个比较特殊的点，`let a = "1"; type(+a)`，可以通过前加号将string转换为Number</font>

boolean类型的转换：

它发生在逻辑运算中（稍后我们将进行条件判断和其他类似的东西），但是也可以通过调用 Boolean(value) 显式地进行转换。
转换规则如下：
- 直观上为“空”的值（如 `0`、空字符串、`null`、`undefined` 和 `NaN`）将变为 `false`。
- 其他值变成 `true`。

## 2.3 值的比较

### 2.3.1 严格相等
普通的相等性检查 `==` 存在一个问题，它不能区分出 `0` 和 `false`
```javascript
alert( 0 == false); // true
alert( "" == false); // true
```

这是因为在比较不同类型的值时，处于相等判断符号 `==` 两侧的值会先被转化为数字。空字符串和 `false` 也是如此，转化后它们都为数字 0。

如果我们需要区分 `0` 和 `false`，该怎么办？
**严格相等运算符 `===` 在进行比较时不会做任何的类型转换。**
换句话说，如果 `a` 和 `b` 属于不同的数据类型，那么 `a === b` 不会做任何的类型转换而立刻返回 `false`。

因为被比较值的数据类型不同。同样的，与“不相等”符号 `!=` 类似，“严格不相等”表示为 `!==`。
```javascript
alert( 0 == false); // true
```

### 2.3.2 null与undefined的特殊比较

```javascript
alert(null === undefined);// false

alert(null == undefined);// true
```


```javascript
alert(null > 0) // false (1)
alert(null == 0) //false (2)
alert(null >= 0) // true (3)
```
产生以上现象的原因：相等性检查 `==` 和普通比较符 `> < >= <=` 的代码逻辑是相互独立的。进行值的比较时，`null` 会被转化为数字，因此它被转化为了 `0`。这就是为什么（3）中 `null >= 0` 返回值是 true，（1）中 `null > 0` 返回值是 false。另一方面，`undefined` 和 `null` 在相等性检查 `==` 中不会进行任何的类型转换，它们有自己独立的比较规则，所以除了它们之间互等外，不会等于任何其他的值

```javascript
alert(undefined > 0) // false  (1)
alert(undefined < 0) // false  (2)
alert(undefined == 0) //false  (3)
```

- `(1)` 和 `(2)` 都返回 `false` 是因为 `undefined` 在比较中被转换为了 `NaN`，而 `NaN` 是一个特殊的数值型值，它与任何值进行比较都会返回 `false`。
- `(3)` 返回 `false` 是因为这是一个相等性检查，而 `undefined` 只与 `null` 相等，不会与其他值相等。

## 2.4 空值合并运算符 '??'

空值合并运算符（nullish coalescing operator）的写法为两个问号 `??`。

由于它对待 `null` 和 `undefined` 的方式类似，所以在本文中我们将使用一个特殊的术语对其进行表示。为简洁起见，当一个值既不是 `null` 也不是 `undefined` 时，我们将其称为“已定义的（defined）”。

`a ?? b` 的结果是：

- 如果 `a` 是已定义的，则结果为 `a`，
- 如果 `a` 不是已定义的，则结果为 `b`。

换句话说，如果第一个参数不是 `null/undefined`，则 `??` 返回第一个参数。否则，返回第二个参数。

空值合并运算符并不是什么全新的东西。它只是一种获得两者中的第一个“已定义的”值的不错的语法。
我们可以使用我们已知的运算符重写 `result = a ?? b`，像这样：

`result = (a !== null &&　a !== undefined) ? a : b`

`??` 的常见使用场景是提供默认值。

例如，在这里，如果 `user` 的值不为 `null/undefined` 则显示 `user`，否则显示 `匿名`：
```javascript
let user;
alert(user ?? "匿名");
```

我们还可以使用 `??` 序列从一系列的值中选择出第一个非 `null/undefined` 的值。

假设我们在变量 `firstName`、`lastName` 或 `nickName` 中存储着一个用户的数据。如果用户决定不填写相应的值，则所有这些变量的值都可能是未定义的。

我们想使用这些变量之一显示用户名，如果这些变量的值都是 `null/undefined`，则显示 “匿名”。

让我们使用 `??` 运算符来实现这一需求：
```javascript
let firstName = null;
let lastName = null;
let nickName = "Supercoder";
// 显示第一个已定义的值：
alert(firstName ?? lastName ?? nickName ?? "匿名"); // Supercoder
```

或运算符 `||` 可以以与 `??` 运算符相同的方式使用。像我们在 [上一章](https://zh.javascript.info/logical-operators#or-finds-the-first-truthy-value) 所讲的那样。

例如，在上面的代码中，我们可以用 `||` 替换掉 `??`，也可以获得相同的结果。

空值合并运算符 `??` 是最近才被添加到 JavaScript 中的，它的出现是因为人们对 `||` 不太满意。

它们之间重要的区别是：

- `||` 返回第一个 **真** 值。
- `??` 返回第一个 **已定义的** 值。

换句话说，`||` 无法区分 `false`、`0`、空字符串 `""` 和 `null/undefined`。它们都一样 —— 假值（falsy values）。如果其中任何一个是 `||` 的第一个参数，那么我们将得到第二个参数作为结果。

不过在实际中，我们可能只想在变量的值为 `null/undefined` 时使用默认值。也就是说，当该值确实未知或未被设置时。

考虑以下情况
```javascript
let height = 0;
alert(height || 100); // 100
alert(height ?? 100); // 0
```

<font color ='red'>优先级问题：</font>：`??`优先级与`||`一致，但是禁止将 `??` 运算符与 `&&` 和 `||` 运算符一起使用，除非使用括号明确指定了优先级。

# 3 拷贝问题

- 浅拷贝是创建一个新对象，这个对象具有原始对象属性值。如果属性是<font color='red'>基本类型</font>的话，拷贝的就是<font color='red'>基本类型</font>。如果属性是<font color='green'>引用类型</font>，拷贝的就是<font color='green'>引用地址</font>，改变了其中一个对象，就会影响到另外一个对象。
- 深拷贝是将一个对象从内存中完整拷贝了一份，从堆内存中开辟了一个新的区域存放新对象，修改后不会影响原来的对象

```javascript
let msg = "yes";
let msg2;
msg2 = msg;
console.log(msg, msg2); // yes yes 
msg = 'yes2';
console.log(msg, msg2); // yes2 yes
```

在JavaScript中，浅拷贝和深拷贝是用来复制对象的两种常见方式。 浅拷贝是创建一个新对象，新对象的属性值是原始对象的引用。换句话说，浅拷贝只复制了对象的第一层属性，而不会递归复制嵌套对象的属性。当修改原始对象的属性时，浅拷贝的对象也会受到影响。 以下是一个使用浅拷贝的示例：

```javascript
let originalObj = { name: "John", age: 30 }; 
let shallowCopyObj = Object.assign({}, originalObj);  
originalObj.name = "Jane";  
console.log(originalObj); // 输出: { name: "Jane", age: 30 }
console.log(shallowCopyObj); // 输出: { name: "John", age: 30 }，浅拷贝的对象不受原始对象修改的影响
```

深拷贝是创建一个新对象，新对象的属性值是原始对象属性的完全独立副本。深拷贝会递归复制所有嵌套对象的属性，确保新对象与原始对象完全独立。即使修改原始对象的属性，深拷贝的对象也不会受到影响。 以下是一个使用深拷贝的示例：

```javascript
let originalObj = { name: "John", age: 30 }; 
let deepCopyObj = JSON.parse(JSON.stringify(originalObj));  
originalObj.name = "Jane";  
console.log(originalObj); // 输出: { name: "Jane", age: 30 } 
console.log(deepCopyObj); // 输出: { name: "John", age: 30 }，深拷贝的对象不受原始对象修改的影响
```

需要注意的是，使用 `JSON.parse(JSON.stringify())` 进行深拷贝时，有一些限制。它无法复制函数、正则表达式、Date对象等特殊类型的属性。此外，如果原始对象中存在循环引用（即对象属性之间相互引用），则会导致深拷贝失败。 因此，在实际开发中，如果需要进行深拷贝，可以使用第三方库（如lodash的 `cloneDeep` 方法）或自己编写递归函数来实现。

# 4 循环标签，箭头函数

## 4.1 循环中的标签

```javascript
for (let i = 0; i < 3; i++) {
  for (let j = 0; j < 3; j++) {
    let input = prompt(`Value at coords (${i},${j})`, '');
    // 如果我想从这里退出并直接执行 alert('Done!')
  }
}
alert('Done!');
```

```javascript
outer: for (let i = 0; i < 3; i++) {  // outer: 另起一行也行
  for (let j = 0; j < 3; j++) {
    let input = prompt(`Value at coords (${i},${j})`, '');
    // 如果是空字符串或被取消，则中断并跳出这两个循环。
    if (!input) break outer; // (*)
    // 用得到的值做些事……
  }
}
alert('Done!');
```

上述代码中，`break outer` 向上寻找名为 `outer` 的标签并跳出当前循环。
因此，控制权直接从 `(*)` 转至 `alert('Done!')`。

## 4.2 箭头函数

函数的创建方式

```javascript
// 标准的创建方法
function funcName(args){
	// ...
}

let funcName = function(){
	// ...
}

// 箭头函数创建

let funcName = (arg1, args2) => expression;

let sum = (a, b) => {
	let result = a + b;
	return result; // 如果使用了花括号，就必须显式
}
```

# 5 浏览器的交互（alert，prompt，confirm）

```javascript
alert("yes") //弹出警告框，没有返回值 undefined
let a = prompt("title",['defaultvalue'])  //弹出模态框，[]中为默认输入，a为输入框中的值
let b = confirm("is it ok?") //弹出确认框，确定返回true，取消返回false
```

# 6 对象

## 6.1 基本的使用
```javascript
let user = {
	name: "MapleWan",
	age: 25,
	"like what": "running",
}

// 属性获取
user.name
user.age
user["like what"] // 这种属性只能这样访问   name属性不能用中括号访问

// 计算属性
let fruit = prompt("which fruit do you like", "apple");
user[fruit] = "Apple";   // 输入的值为属性名
user[fruit + "computer"] = "Mac"
console.log(user.apple)  
```

## 6.2 属性值的简写

```javascript
function makeUser(name, age){
	return {
		name : name, 
		age : age,
	}
	// 可以简写为以下
	//return {
	//	name,
	//	age,
	//}
}

// 可以通过 "属性名 in 对象" 来判断对象是否包含某一个属性   如
"name" in user;
```

## 6.3 关于对象的拷贝问题

```javascript
let obj = {};
let obj2 = obj;
console.log(obj == obj2);  // true
console.log(obj === obj2); // true


// 要使上面成为两个独立的对象
let user = {
  name: "John",
  age: 30
};
let clone = {}; // 新的空对象
// 将 user 中所有的属性拷贝到其中
for (let key in user) {
  clone[key] = user[key];
}
// 现在 clone 是带有相同内容的完全独立的对象
clone.name = "Pete"; // 改变了其中的数据
alert( user.name ); // 原来的对象中的 name 属性依然是 John


// 也可以使用 Object.assign方法
```

`Object.assign(dest, [src1, src2, src3...])`
```javascript
let user = {name : "John"};
let permission1 = {canView : true};
let permission2 = {canEdit : true};

// 将permission1和permission2的所有属性拷贝到user中
Object.assign(user, permission1, permission2);
// 现在的user = {name: "John", canView: true, canEdit: true}

Object.assign(user, {name: "Peter"}) // 会覆盖已经存在的属性 

let clone = Object.assign({}, user) // 可以使用Object.assign 进行简单克隆

```

以上对象的属性都是基础类型的赋值，当对象中的属性是引用类型的时候，拷贝过去的对象属性值可能还会是指向同一个内存。如以下
```javascript
let user = {
  name: "John",
  sizes: {
    height: 182,
    width: 50
  }
};

let clone = Object.assign({}, user);
alert( user.sizes === clone.sizes ); // true 同一个对象

user.sizes.width++;
alert(clone.sizes.width) // 51  一个值改变，另外一个跟着变化
```

为了解决这个问题，并让 `user` 和 `clone` 成为两个真正独立的对象，我们应该使用一个拷贝循环来检查 `user[key]` 的每个值，如果它是一个对象，那么也复制它的结构。这就是所谓的“深拷贝”。

我们可以使用递归来实现它。也可以采用现有的实现，例如 [lodash](https://lodash.com/) 库的 `_.cloneDeep(obj)`

## 6.3 成员方法
```javascript
let user = {
    name: "MapleWan",
    age: 25,
    "like what": "running",
    sayHello : function(){
        return "hello" + this.name;
    },
    sayHi(){
        return "hi";
    },
}

function saySorry(){
    return "sorry";
}
let yes = function(){
    return "yes";
}
user.saySorry = saySorry;
user.yes = yes;

console.log(user.sayHello()); // hello
console.log(user.sayHi());   // hi
console.log(user.saySorry()); // sorry
console.log(user.yes()); //yes
```

## 6.4 构造方法

常规的 `{...}` 语法允许创建一个对象。但是我们经常需要创建很多类似的对象，例如多个用户或菜单项等。

这可以使用构造函数和 `"new"` 操作符来实现。

构造函数在技术上是常规函数。不过有两个约定：
1. 它们的命名以大写字母开头。
2. 它们只能由 `"new"` 操作符来执行。
```javascript
function User(name){
	this.name = name;
	// return this; // 隐式返回了this对象
	// 当没有return的时候 默认返回this对象
	// 当有return具体的对象的时，  如  return {name : "Maple"}, 则返回这一个具体的对象“{name : "Maple"}”
}

let user = new User("Jack");
console.log(user.name);
```

## 6.5 可选链

`?.`
```javascript
// 如果 document.querySelector('.elem') 的结果为 null，则这里不存在这个元素
let html = document.querySelector('.elem').innerHTML; // 如果 document.querySelector('.elem') 的结果为 null，则会出现错误

let user = {}; // 没有address 属性的user对象
console.log(user.address.stree); //  ERROR!
// 为了避免报错，我们一般的解决方法是采用判断，如下
console.log(user.address ? user.address.street : undefined);
// 这样可以，这里就不会出现错误了……但是不够优雅。就像你所看到的，"user.address" 在代码中出现了两次
```


如果可选链 `?.` 前面的值为 `undefined` 或者 `null`，它会停止运算并返回 `undefined`。

**为了简明起见，在本文接下来的内容中，我们会说如果一个属性既不是 `null` 也不是 `undefined`，那么它就“存在”。**

换句话说，例如 `value?.prop`：

- 如果 `value` 存在，则结果与 `value.prop` 相同，
- 否则（当 `value` 为 `undefined/null` 时）则返回 `undefined`。

下面这是一种使用 `?.` 安全地访问 `user.address.street` 的方式：
```javascript
let user = {};
console.log( user?.address?.street);  // undefined 不报错
```

如果 `?.` 左边部分不存在，就会立即停止运算（“短路效应”）。

因此，如果在 `?.` 的右侧有任何进一步的函数调用或操作，它们均不会执行。如

```javascript
let user = null;
```

# 7 symbol

## 7.1 基本功能
 对于对象的属性键，只有两种原始的数据类型，字符串类型（Number或默认转为string）或者symbol类型。如`obj[1]` 与 `obj["1"]` 相同，而 `obj[true]` 与 `obj["true"]` 相同。可以使用`symbol`来唯一标识它们。如
```javascript
let id1 = Symbol("id")
let id2 = Symbol("id")
id1 == id2 // false

// symbol 无法自动转换为字符串，需要显式转换，如
alert(id1) // 会报错
alert(id1.tostring())  // 需要显式转换为字符串
```

## 7.2 隐藏属性

```javascript
let user = {
	name = "John",
};
let id = Symbol("id");
user[id] = 1;
alert(user[id]); 
// 在创建一个Symbol值为“id”的属性，也不会报错，因为Symbol是唯一的

school = Symbol("csu")
let maple = {
    name: 'maple',
    age: 18,
    [school]: "sfqz"
}
// 这里是没法输出[school]这个symbol的
for(let key in maple){
    console.log(key+":"+maple[key])
}
```

## 7.3 